---
layout: post
title: Java 字节码学习笔记
date: 2019-04-30 16:39
---

- Java 字节码
- Java 字节码结构
- Java 字节码增强技术



## Java 字节码

### 为什么叫 Java 字节码？

>  字节码文件由十六进制值组成， JVM 以 2 个十六进制值为 1组 进行读取, (2个16进制值表示一个字节）;

> Java 可以一次编译，到处运行的原因：    
> 1. JVM 针对各种操作系统、平台进行了定制；
> 2. 无论在什么平台，都可以编译生成固定的字节码（.class 文件）供 JVM 使用

**字节码很重要**

通过字节码可以直观的看到 Volatile 关键字如何在字节码上生效？？

JVM 字节码操作集合 --> Java 中操作字节码的框架

## Java 字节码结构

> 字节码文件是由一堆十六进制数组成；

![字节码结构](/assets/images/cafebabe.jpg)


> JVM 要求字节码文件必须由一下 10 个部分按照顺序组成：

#### 魔数（Magic）
    所有 .class 文件的前 4 个字节都是魔数，魔数的固定值为: 0xCAFEBABE. 魔数被放在文件开头， JVM 根据 文件开头来判断这个文件是否可能是 .class 文件 

#### 版本号（Version）
    版本号是魔数之后的 4 个字节， 前 2 个字节表示次版本号（Minor Version）， 后 2 个字节表示主版本号（Major Version）。
    上图版本号为：「00 00 00 34」， 次版本号转化为十进制是 0 ， 主版本号转化为十进制是 52，Oracle 官网查询到序号 52 的版本号为 1.8 , 
    所以编译该文件的 Java 版本号为 1.8

#### 常量池（Constant_pool）
    常量池中存储 2 类常量： 字面量&符号引用。
    字面量： 代码中声明为 final 的常量值；
    符号引用： 类/接口的全局限定名、字段名称和描述符、方法名称和描述符
    常量池整体分为 2 个部分： 描述常量池计数器 和 常量池数据区
    
    - 常量池计数器： 常量的数量是不固定的， 所以先放置 2 个字节来表示常量池的容量计数值
    - 常量池数据区： N 个字节来描述代码中的常量， 可以通过javap -verbose xxx 来查看 JVM 反编译后的完整常量池。

#### 访问标志（access_flag）
    2 个字节 描述该 class 是类还是接口，以及是否被 public, Abstract, Final 等修饰

#### 当前类索引（this_class）
    2个字节描述当前类的全限定名

#### 父类索引（super_class）
    2个字节描述父类的全限定名

#### 接口索引（interfaces）
    2 个字节的接口计数器， 描述了该类/父类实现的接口数量，N 个字节描述所有接口名称的字符串常量的索引值

#### 字段表（fields）
    描述类和接口中声明的变量，但不包含方法内部声明的局部变量
    字段表分为 2 个部分：描述字段个数和字段详细信息

#### 方法表（methods）
    方法表分为 2 部分组成，描述方法的个数 和 每个方法的详细信息
    
#### 附加属性（attributes）
    类或接口所定义属性的基本信息


### 操作数栈和字节码
JVM 指令集基于栈进行操作而不是在寄存器中操作，
原因是：基于栈可以有很好的跨平台性（因为寄存器指令集往往和硬件挂钩）
但是缺点是：
1. 要完成同样的操作，基于栈的实现需要更多指令才能完成（因为栈是一个 FIFO 结构， 需要频繁的压栈出栈）
2. 栈的速度慢很多因为：
- 栈是在内存实现
- 寄存器是在 CPU 的高速缓存区

但是为了跨平台只好作出牺牲


操作码，操作集合 控制的都是 JVM 的操作数栈


什么是「字节码增强技术」 就是对现有字节码进行修改/动态生成全新字节码文件的技术。
      
![字节码增强技术(摘自其他网站)](/assets/images/bytecode.jpg)
     
     - AOP
     - CGLIB
     - ASM
     - AspectJ
     - Java Proxy
     - Javassist

-------------------------------------------------------------  

「字节码增强技术」应用场景: 
- Spring AOP
- ORM 框架
- 热部署

ASM: 手动操纵字节码。直接生产 .class 文件，也可以在类被加载汝 JVM 前动态修改
ASM 的应用场景有：AOP（Cglib 就是基于 ASM）、热部署、修改其他 jar 包中的类等。

ASM 的 2 种 API, 并用 ASM 实现 一个比较粗糙的 AOP 

访问者模式



原文参考：